# 4.数组和特殊矩阵
## 4.1数组的存储结构
对于二维矩阵，数组有两种存储方法：
<img src="(临时)对称矩阵的压缩算法.assets/image-20230917190744138.png" alt="image-20230917190744138" style="zoom: 67%;" />

### 4.1.1 行优先
<img src="(临时)对称矩阵的压缩算法.assets/image-20230917190818889.png" alt="image-20230917190818889" style="zoom: 67%;" />
对于采用**行优先**存储的**M行N列**的矩阵，B\[ i \]\[ j \]的存储位置为:

```c
ElemType M[i][j];
M[i][j] == M(LOC) + (i*N+j)*sizeof(ElemType);//B(LOC)为数组B的起始地址
//i*N是前i行的元素总数，j是第i+1行的元素个数
```

### 4.1.2 列优先
<img src="(临时)对称矩阵的压缩算法.assets/image-20230917190848386.png" alt="image-20230917190848386" style="zoom:67%;" />
对于采用**列优先**存储的**M行N列**的矩阵，B\[ i \]\[ j \]的存储位置为:

```c
ElemType M[i][j];
M[i][j] == M(LOC) + (j*M+i)*sizeof(ElemType);//B(LOC)为数组B的起始地址
//j*M是前j列的元素总数，i是第j+1行的元素个数
```

## 4.2特殊矩阵的压缩算法
### 4.2.1对称矩阵的压缩存储
对称矩阵一定是方阵。
策略：只存储主对角线 + 下三角区

1. 按**行优先**原则将各元素存入一维数组中。

#### 压缩后的大小
>设矩阵的规模为n，则一维数组的大小为：
>```c
>(1+n)*n/2   //等差数列求和公式Sn=n(a1+an)/2=n*a1+n*(n-1)d/2
>```
>所以一维矩阵的下标范围为：
>```c
>[0,((1+n)*n / 2)-1]
>```

#### 矩阵下标--->一维数组下标

矩阵M`M[i][j]`的**`i和j的取值范围为[1,n-1]`**。
**注意**：*矩阵的下标一般从1开始a1,1 a1,2 a1,3等，但数组的下标一般从0开始。*

>一、按照**行优先**的原则，`M[i][j]`是一维数组中第几个元素？
>
>1. 当 `i>=j`，即`M[i][j]`为下三角及主对角线中的元素时：
>```c
>//前i-1行的元素总数为(0+1+2+3+4+5····+i-1),i-1是第i-1行的元素个数
>M[i][j]=CM[i*(i-1)/2+j-1]//i*(i-1)/2是矩阵下三角前i-1行元素个数的和，j是第i行元素个数，从0开始计数所有要-1
>```
>
>2. 当`j<i`，即`M[i][j]`为上三角中的元素时：
>```c
>M[i][j]=M[j][i]=CM[j*(j-1)/2+j-1]//因为是对称矩阵，所以M[i][j]=M[j][i],而M[j][i](j>i)是下三角,可以用套用i>=j时的公式
>```
>
>二、按照**列优先**的原则：
>1. 当`i>=j`，既`M[i][j]`为下三角及主对角线中的元素时：
>```c
>/*前j-1列的元素总数为：
>n+(n-1)+(n-2)+(n-3)+(n-4)+····+( n-((j-1)-1))= 
>*/
>M[i][j]=CM[j*(n+n-((j-1)-1))/2 + (i-j)+1]=CM[j*(2n-j+2)/2 + (i-j)+1]//j(2n-j+2))/2是前j-1列元素的和，(i-j)是在第j列中目标元素前的元素个数，然后+1就是目标元素
>```
>2. 当`i<j`，即`M[i][j]`为上三角中的元素时：
>```c
>M[i][j]=M[j][i]=CM[i*(2n-i+2)/2 + (j-i)+1]//因为是对称矩阵，所以M[i][j]=M[j][i],而M[j][i](j>i)是下三角,可以用套用i>=j时的公式求得
>```
>
>