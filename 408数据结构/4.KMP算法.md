#  KMP算法
KMP的名字是由三位发明它的人的名字命名的。
KMP算法是为了弥补朴素模式匹配算法的缺点：当某些子串与模式串能部分匹配时，**珠串的扫描指针i经常回溯**,导致时间开销增加。
所以KMP算法只在**子串与模式串经常出现部分匹配**的时候才会比朴素模式匹配快许多。

## 字符串结构的实现
由于c语言不存在字符串这种数据结构，只存在字符数组。
所以字符串这种数据结构可以自己定义。
王道教材使用的实现字符串的数据结构是：
![image-20230925205151532](C:\Users\dww\AppData\Roaming\Typora\typora-user-images\image-20230925205151532.png)

这样一种格式，代码为：
```c
#define MAXLEN 255		//预定义最大串长为255
typedef struct{
char ch[MAXLEN];		//每个分量存储一个字符
int length;				//串的实际长度
}SString;
```
这种还是使用数组来实现字符串，但是字符串的下标与位数是一一对应的（舍弃了第一个位置），而且结构中包含了字符串的长度。
## 补充知识
1. 前缀
所有含第一个字符，但不含最后一个字符的子串。
2. 后缀
所有含最后一个字符，但不含第一个字符的子串。
3. 部分匹配值
字符串的前缀和后缀的**最长相等前后缀的长度**。
4. **部分匹配值表(Partial Match,PM)**
用部分匹配值形成的表。
例如：
>'a'的前缀和后缀都为空集，最长相等前后缀为{∅}，部分匹配值为0，
>部分匹配值形成的表为：
>| a |
>| 0 |

>'ab'的前缀为{a}，后缀为{b}，最长相等的前后缀为{∅}，部分匹配值为0，
>部分匹配值形成的表为：
>| a | b |
>| 0 | 0 |

>'aba'的前缀为{a,ab}，后缀为{ba,a}，最长相等前后缀为{a}，部分匹配值为1，
>部分匹配值形成的表为：
>| a | b | a |
>| 0 | 0 | 1 |

>'abab'的前缀为{a,ab,aba}，后缀为{bab,ab,a}，最长相等前后缀为{ab}，部分匹配值为2，
>部分匹配值形成的表为：
>| a | b | a | b |
>| 0 | 0 | 1 | 2 |

>'ababa'的前缀为{a,ab,aba,abab}，后缀为{baba,aba,ba,a}，最长相等前后缀为{aba}，长度为3，
>部分匹配值形成的表为：
>| a | b | a | b | a |
>| 0 | 0 | 1 | 2 | 3 |

## KMP原理
利用PM表来进行跳跃式的匹配。
## KMP算法
### next数组手算

1. 方法一：
由前1~`j`-1个字符组成的串计为S,则：
next[`j`]=`S的最长相等前后缀长度`+1
特别的，next[ 1 ]=0
2. 方法二：
例如对式子`abcdabca`求PM表,让`j`位于第一位，`i`位于第二位

```
第一步
| j | i |   |   |   |   |   |   |
| a | b | c | d | a | b | c | a |
| 0 | 0 |   |   |   |   |   |   |
```

比较`j`与`i`对应的字符：
如果相等，就使得`i`字符下面的数值变为`j`+1，然后把`i`和`j`都往后移一位；
如果不相等，就把`i`往后移一位，重新开始比较。

```
第二步
| j |   | i |   |   |   |   |   |
| a | b | c | d | a | b | c | a |
| 0 | 0 |   |   |   |   |   |   |
```
```
第三步
| j |   |   | i |   |   |   |   |
| a | b | c | d | a | b | c | a |
| 0 | 0 | 0 | 0 |   |   |   |   |
```
```
第四步
| j |   |   |   | i |   |   |   |
| a | b | c | d | a | b | c | a |
| 0 | 0 | 0 | 0 | 1 |   |   |   |
```
```
第五步
|   | j |   |   |   | i |   |   |
| a | b | c | d | a | b | c | a |
| 0 | 0 | 0 | 0 | 1 | 2 |   |   |
```
```
第六步
|   |   | j |   |   |   | i |   |
| a | b | c | d | a | b | c | a |
| 0 | 0 | 0 | 0 | 1 | 2 | 3 |   |
```
```
第七步
|   |   |   | j |   |   |   | i |
| a | b | c | d | a | b | c | a |
| 0 | 0 | 0 | 0 | 1 | 2 | 3 | 0 |
```
求出PM表后，把PM表整体向右移动一位，最左边空出的一位用-1填充，然后整体+1就是next数组。
```
|   |   |   |   |   |   |   |   |
| a | b | c | d | a | b | c | a |
| 0 | 1 | 1 | 1 | 1 | 2 | 3 | 4 |
```
### KMP机算
next机算是由手算优化得来的：
```c
int* getNext(SString pattern){
    int* next=(int*)malloc(sizeof(int)*(pattern.length+1));//next数组的长度为模式串长度+1,因为next[0]废弃不用
    next[0]=-1;//next[0]废弃不用，因为要和模式串对齐.
    next[1]=0;//next[1]的值为0，pm表中为-1,整体加一后变为0
    int i=1;//模式串的下标
    int j=0;//主串的下标，
    while(i<pattern.length){//i<pattern.length说明模式串还没有遍历完
        if(j==0||pattern.ch[i]==pattern.ch[j]){//模式串的第i个字符和第j个字符匹配时，或者j=0时,(j=0说明模式串的第一个字符和主串的第i个字符不匹配，所以j要回溯)
            i++;
            j++;
            next[i]=j;//让next[i]的值等于j,开始回溯.(示在i位置匹配失败时，让模式串的第j个字符和主串的第i个字符开始匹配)
        }else{
            j=next[j];//如果不匹配,j值回溯
        }
    }
    return next;
}
```