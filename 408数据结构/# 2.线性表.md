# 2.线性表
线性表是一种逻辑结构，实现它的逻辑结构有
- 顺序存储
    在内存中分配一大块连续的地址来存储数据，用连续的物理顺序来体现逻辑顺序。
- 链式存储
    除了存储数据外，还要存储指向下一个数据的指针，每一个数据被随机分配在整个内存中，靠指向下一个数据的指针来体现逻辑顺序。
    分别对应顺序表和链表。
    线性表常用的基本运算有
```c
InitList(*LinkList):                  //初始化表
Length(Link):					      //求表长
LocateElem(Link,e):			          //按值查找
GetElem(Link,i):				      //按位查找
ListInsert(*LinkList，i,e):			 //插入操作
ListDelete(*LinkList,i,*e):		      //删除操作
Empety(Link):					      //判空操作
DestroyList(*LinkList):			      //消毁操作
//还有排序，合并，逆置等等操作
```
一般有三种传入值来代表链表，按照函数所要进行修改的不同来区分：
```
1.const LinkList 类型(指针常量类型，只能读取链表内容和头指针指向，无法通过指针修改二者)
2.LinkList 类型(是指向链表的指针类型，一般代指链表头指针，可以读取修改链表内容，但无法修改头指针，只能读取头指针)
3.LinkList* 类型(指向头指针的指针类型，可以读取和修改链表内容和头指针指向)
```
## 2.1顺序表
按照是否可以进行容量的扩充分为静态顺序表和动态顺序表。
### 2.1.1静态顺序表
常见定义结构：
```c
#define MaxSize 50					//定义最大长度
typedef struct sqList{				
	int data[MaxSize];				//顺序表的元素
	int length;						//顺序表的当前长度
}sqList;							//顺序表的别名
```
静态顺序表的容量一般由宏定义来指定，表一旦初始化完成，容量就固定，无法再更改。
### 2.1.2动态顺序表
常见定义结构：
```c
#define InitSize 50					//表长度的初始定义
typedef struct seqList{				//
	int* data;						//指向动态分配数组的指针
	int MaxSize;					//数组的最大容量
	int length;						//数组的当前容量
}seqList;							//动态分配数组顺序表的类型定义
```
动态顺序表的容量可以进行扩充，当初始化产生的数组容量用完时，就重新开辟一片更大的地址，然后转移当前数组中的数据到新的数组中，然后让seqList->data重新指向新的数组,并释放旧的内存。
## 2.2链表

### 不同的链表
链表的每个节点分为两个部分，数据域和指针域。
- 单链表
  指针域只存放指向后继节点的指针(每个节点单指针)
- 双链表 
  指针域既有指向前驱节点的指针，也有指向后继节点的指针(每个节点两个指针)。
- 循环链表
  在单链表和双链表的基础上，让链表最后一个节点的后继指针不为空，使其指向第一个节点；第一个节点的前驱节点指向最后一个节点(若有的话)。
- 静态链表
  低配的链表，用于一些没有指针的低级语言，其用一片连续的内存空间(数组)来存储链表，每个节点的指针域用来存放后继节点的数组游标，且容量固定，生成后就无法更改。
### 为什么要引入头节点
链表还分为**含头结点的链表和不含头结点**的链表，引入头结点有两个优点：
1.因为引入了头结点，使得第一个数据元素得到了前驱节点(使得链表中所有的节点都有了前驱节点)，统一了第一个元素与其他元素的操作(插入，删除等)。
2.无论链表是否为空，头指针永远都是指向头结点的，因此空表与非空表的操作得到了统一。
### 2.2.1单链表
常见定义结构：
```c
typedef struct Lnode{
    int data;
    struct Lnode *next;
}Lnode,*LinkList;
```
含头结点的初始化：
给头结点分配内存，然后让头指针指向头结点，让头结点的next悬空。

```c
int initList(LinkList* pointerToList){
    *pointerToList = (Lnode*)malloc(sizeof(Lnode));         //为头节点分配内存，然后让头指针指向头结点。
    if((*pointerToList)==NULL){
        printf("ERROR,Memory allocate failed.\n");
        return 1;
    }
    (*pointerToList)->data = 0;							//初始化头结点
    (*pointerToList)->next = NULL;						//初始化头结点
    return 0;
}
```
不含头结点的初始化：
让头指针悬空。

```c
int initList(LinkList* pointerToList){		//PointerToList为指向LinkList的指针
	*pointerToList = NULL;					//让头指针悬空
	return 0;
}	
```
### 2.2.2双链表
常见定义结构：
```c
typedef struct DLnode{
    int data;
    struct DLnode *prior,*next;
}DLnode,*DLinkList;
```

初始化与单链表一致，不含头结点就让头指针悬空，含头结点给头结点分配内存，然后让头结点的指针悬空。

单链表访问前驱结点的时间复杂度为O(n),双链表访问前驱结点的复杂度为O(1)。

### 2.2.3循环链表
不同于非循环链表，循环链表可以在链表的任意位置开始遍历整个链表，（选择放置尾指针，让获取表尾元素不要遍历整个链表(更快)，且该变化不影响其他操作）
- 循环单链表
使得尾指针成为更优的选择。
- 循环双链表
同上。
### 2.2.4静态链表
用于没有指针的语言，低配版链表。
很少用。

### 2.2.5总结
单链表的删除和插入操作都需要通过遍历(时间复杂度为O(n))得到目标节点的前缀节点。
## 2.3总结
### 不同点
1. 存取方式
    顺序表可以顺序存取，也可以随机存取(可直接得到任意位置的数据)，但是链表只能顺序存取，只能从表头或者表尾遍历得到某个元素。
2. 逻辑结构和物理结构
    顺序表的中，逻辑上相邻的元素，物理结构也相邻。在链表中，逻辑结构相邻通常不会使得物理结构相邻，链表的逻辑结构由指针来体现。
3. 查找、删除、插入操作
    对于按值查找，顺序表无序时，时间复杂度为O(n),顺序表有序时,可以使用二分法查找，时间复杂度为O(log2n)。
4. 空间分配
    顺序表的静态分配无法拓展空间，分配内存太小容易造成内存溢出，分配太大会造成表的后半部分大量闲置。动态分配虽然可以拓充空间，但是又需要大量移动元素，导致效率降低，且拓展需要更大块的连续内存空间，容易拓展失败。链表只在需要时申请空间分配，所有操作更灵活、高效。
### 如何选取
1. 基于存储的考虑
如果难以估计线性表的长度或存储规模，不宜选择顺序表；链表不要事先估计规模，但是存储密度小于1。
2. 基于用算的考虑
如果经常使用**查找操作**，顺序表按序号访问的时间复杂度为O(1)，而链表为O(n)；按照值查找时，若表为无序表，顺序表的时间复杂度为O(n)，链表也为O(n)，若为有序表，顺序表可以使用二分查找，复杂度为O(log2n)，链表还是为O(n)，此时显然**优先选取顺序表**。
如果经常使用的是**插入删除操作**，顺序表平均每次需要移动的量是一半的元素，时间复杂度为O(n)，当数据规模较大时，耗时会随之增大；链表虽然也要寻找插入位置，时间复杂度也为O(n)，但进行的是比较操作，**链表耗时会明显低于顺序表**。
3. 基于环境的考虑
顺序表比链表更容易实现，任何高级语言都有数组类型，链表的操作是基于指针，相对来说顺序表更容易实现。
**通常比较稳定的线性表选择使用顺序表，而需要频繁插入删除的线性表选择用链表实现。**
