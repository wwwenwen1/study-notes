# 2.线性表
线性表是一种逻辑结构，实现它的逻辑结构有
- 顺序存储
    在内存中分配一大块连续的地址来存储数据，用连续的物理顺序来体现逻辑顺序。
- 链式存储
    除了存储数据外，还要存储指向下一个数据的指针，每一个数据被随机分配在整个内存中，靠指向下一个数据的指针来体现逻辑顺序。
    分别对应顺序表和链表。
    线性表常用的基本运算有
```c
InitList(*LinkList):                  //初始化表
Length(Link):					      //求表长
LocateElem(Link,e):			          //按值查找
GetElem(Link,i):				      //按位查找
ListInsert(*LinkList，i,e):			 //插入操作
ListDelete(*LinkList,i,*e):		      //删除操作
Empety(Link):					      //判空操作
DestroyList(*LinkList):			      //消毁操作
//还有排序，合并，逆置等等操作
```
一般有三种传入值来代表链表，按照函数所要进行修改的不同来区分：
```
1.const LinkList 类型(指针常量类型，只能读取链表内容和头指针指向，无法通过指针修改二者)
2.LinkList 类型(是指向链表的指针类型，一般代指链表头指针，可以读取修改链表内容，但无法修改头指针，只能读取头指针)
3.LinkList* 类型(指向头指针的指针类型，可以读取和修改链表内容和头指针指向)
```
## 2.1顺序表
按照是否可以进行容量的扩充分为静态顺序表和动态顺序表。
### 2.1.1静态顺序表
常见定义结构：
```c
#define MaxSize 50					//定义最大长度
typedef struct sqList{				
	int data[MaxSize];				//顺序表的元素
	int length;						//顺序表的当前长度
}sqList;							//顺序表的别名
```
静态顺序表的容量一般由宏定义来指定，表一旦初始化完成，容量就固定，无法再更改。
### 2.1.2动态顺序表
常见定义结构：
```c
#define InitSize 50					//表长度的初始定义
typedef struct seqList{				//
	int* data;						//指向动态分配数组的指针
	int MaxSize;					//数组的最大容量
	int length;						//数组的当前容量
}seqList;							//动态分配数组顺序表的类型定义
```
动态顺序表的容量可以进行扩充，当初始化产生的数组容量用完时，就重新开辟一片更大的地址，然后转移当前数组中的数据到新的数组中，然后让seqList->data重新指向新的数组,并释放旧的内存。
## 2.2链表

链表的每个节点分为两个部分，数据域和指针域。
- 单链表
  指针域只存放指向后继节点的指针(每个节点单指针)
- 双链表 
  指针域既有指向前驱节点的指针，也有指向后继节点的指针(每个节点两个指针)。
- 循环链表
  在单链表和双链表的基础上，让链表最后一个节点的后继指针不为空，使其指向第一个节点；第一个节点的前驱节点指向最后一个节点(若有的话)。
- 静态链表
  低配的链表，用于一些没有指针的低级语言，其用一片连续的内存空间(数组)来存储链表，每个节点的指针域用来存放后继节点的数组游标，且容量固定，生成后就无法更改。

链表还分为**含头结点的链表和不含头结点**的链表，引入头结点有两个优点：
1.因为引入了头结点，使得第一个数据元素得到了前驱节点，统一了第一个元素与其他元素的操作(插入，删除等)。
2.无论链表是否为空，头指针永远都是指向头结点的，因此空表与非空表的操作得到了统一。
### 2.2.1单链表
常见定义结构：
```c
typedef struct Lnode{
    int data;
    struct Lnode *next;
}Lnode,*LinkList;
```
含头结点的初始化：
给头结点分配内存，然后让头指针指向头结点，让头结点的next悬空。

```c
int initList(LinkList* pointerToList){
    *pointerToList = (Lnode*)malloc(sizeof(Lnode));         //为头节点分配内存，然后让头指针指向头结点。
    if((*pointerToList)==NULL){
        printf("ERROR,Memory allocate failed.\n");
        return 1;
    }
    (*pointerToList)->data = 0;							//初始化头结点
    (*pointerToList)->next = NULL;						//初始化头结点
    return 0;
}
```
不含头结点的初始化：
让头指针悬空。
```c
int initList(LinkList* pointerToList){		//PointerToList为指向LinkList的指针
	*pointerToList = NULL;					//让头指针悬空
	return 0;
}	
```
### 2.2.2双链表
常见定义结构：
```c
typedef struct DLnode{
    int data;
    struct DLnode *prior,*next;
}DLnode,*DLinkList;
```

初始化与单链表一致，不含头结点就让头指针悬空，含头结点给头结点分配内存，然后让头结点的指针悬空。

单链表访问前驱结点的时间复杂度为O(n),双链表访问前驱结点的复杂度为O(1)。

### 2.2.3循环链表
不同于非循环链表，循环链表可以在链表的任意位置开始遍历整个链表。
- 循环单链表

- 循环双链表

### 2.2.4静态链表
用于没有指针的语言，低配版链表。


## 2.3总结






