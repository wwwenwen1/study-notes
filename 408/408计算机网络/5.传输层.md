# 5. 传输层

## 5.1 传输层提供的服务

![image-20250623204429847](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250623204429847.png)

Socket（套接字）就是IP地址加端口号

---

### 5.1.1 端口

端口号一共有2^16^=65536个，0~65535之间

网络层层实现了**主机到主机**的通信。

传输层实现了**端到端（进程到进程）**的通信。传输层在TCP（或UDP）指明了源端口、目的端口。

![image-20250623205449549](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250623205449549.png)

> 不同主机端口号独立
>
> 不同协议TCP和UDP的使用的端口号独立

**熟知端口号的范围是0~1023**

### 5.2 传输层的功能

#### 5.2.1 复用和分用

复用（从上到下）：在发送数据的时候，同一台主机上的多个进程可以使用同一个传输层协议。

分用（从下到上）：在接受数据的时候，传输层可以把数据正确交付到目的进程。

### 5.2.2 差错检测

TCP检测到差错后丢弃数据，并通知发送方重传

UDP检测出错误后直接丢弃数据，**且不通知发送方**

### 5.2.3 向应用层提供两种服务

TCP：面向连接的、可靠的端到端传输服务——确保数据正确/完整，但开销大、实时性较差(**一定交付**)

UDP：不可靠的端到端传输服务——数据可能出错/丢失，但速度快、开销小（**努力交付**）

![image-20250623211847800](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250623211847800.png)



## 5.2 UDP数据报

UDP与TCP的对比

![image-20250625150553271](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250625150553271.png)

![image-20250625150932089](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250625150932089.png)

---

###   5.2.1 UDP数据报的格式

![image-20250625155446963](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250625155446963.png)

---



![image-20250625152036525](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250625152036525.png)

### 5.2.2 UDP检验(检验和)

![image-20250625153358339](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250625153358339.png)

> 让两个16bit的数据相加，得到中间结果。再获取中间结果的按位取反，此时可以看出，中间结果与它的按位取反相加得全1。可知两个16位bit串与按位取反的结果相加也得全1。

当有更多数据时，也是每16bit一组，让前两个组相加，然后结果再与剩下的组相加。

**回卷**：指的是当相加过程中，最高位发生进位时（最左边的一位发生进位），就把进位的1加到最低位（最右边的一位）。

![image-20250625154212505](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250625154212505.png)

![image-20250625154950140](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250625154950140.png)

添加伪首部再进行校验和（不要问为什么，不重要）

2B，  16bit的校验和。

> IP数据报的首部校验和与UDP的校验和类似，但是计算时不添加伪首部。



## **5.3TCP协议*****

 TCP协议有三大阶段：

- 建立连接（三次握手）
- 数据传输
- 释放连接（四次挥手）

![image-20250626160202494](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250626160202494.png)

> 一次TCP可以传输多个报文段

![image-20250626161126110](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250626161126110.png)

**MSS只包含TCP的数据段大小。**

> TCP可以主动分段再打包成IP数据报；UDP不能自己分段，只能靠IP数据报分段。

### 5.3.1 TCP报文段的格式

![image-20250626161838726](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250626161838726.png)

1. 源端口和目的端口

各占用2B，用来标记应用层发送方与接收方的端口号。

2. **序号（seq）***  

占4B，范围为0~ 2^32^-1，共2^32^序号。TCP连接中传送的字节流中的每个字节都要按顺序编号，序号字段的值指的是本报文段所发送的数据的第一个字节的序号。

> **建立连接的双方各自确定一个seq序列号**，例如客户端从1000开始。服务器端从5000开始。然后对方的ack根据数据接收情况，以自己发送过去的 seq + 对方成功接受的数据大小，进行回应。 

3. **确认号(ack或ack_seq)***

占4B，是期望收到对方的下一个报文段的第一个数据字节的序号。若确认号为N，则表明到序号N-1为止的所有数据都已正确收到。**累计确认**

> **一般是对方发来报文的 seq号 + 1 。**假设收到的上一个报文的seq为1000，则本次发送的ack值为1001，表示我已正常收到所有序号小于1001的数据，期待下一次收到 seq=1001 开始的数据。

4. 数据偏移（首部长度）

占4bit，取值范围0~15，故TCP首部长度最大为15*4=60字节。

5. 保留

占6位，没啥用。全为0

6. 紧急位URG

当URG为1时，表示这是紧急数据，应该尽快插队发送。紧急数据会被插到报文数据段的最前面。

> 紧急数据：例如文字聊天信息

7. 确认位ACK

当ACK为1时，确认号字段才有效。连接建立后所有的传送报文ACK位都为1。

8. 推送位PSH

两个交互式进程进行交互式通信时，都希望在键入一个命令后立即就能收到对方的响应，此时发送方TCP把PSH置为1，接收方TCP收到PSH=1的报文段后,就尽快交付给应用进程。

> 例如游戏进程与服务器的交互

9. 复位位RST

RST=1表示发生了严重差错（主机崩溃等），必须释放连接，然后重新建立连接。

10. 同步位SYN*

SYN=1,表示这是一个连接请求或连接接受请求。

11. 终止位FIN*

FIN=1,表示这是一个连接释放的信息。

> **只有握手1和握手2的SYN=1,其他所有报文都是SYN=0**
>
> **只有挥手1和挥手3的FIN=1,其他所有报文的FIN=0**

12. **窗口（rwnd或rcvwnd）**

占2B，表示接受窗口的大小。从本报文段首部中的确认号算起接收方目前允许对法发送的数据量（以字节为单位）。接收方的数据缓存空间是有线的，因此窗口值作为接收方让发送方设置其发送窗口的依据。

> 假如确认号是701，窗口字段是1000.这表明从701算起，发送此报文段的乙方还要接受1000字节数据（字节序号为701~1700）的接受缓存空间。

13. 检验和

占2B，和UDP雷同，计算前先加上12B的伪首部。（协议字段17改为6，UDP长度改为TCP长度）

14. 紧急指针

 当URG为1时，指出本报文中紧急数据的字节数（在报文段数据的最前面）。

15. 选项

长度可变，最大为40B，协商确定MSS的大小。

16. 填充

使得TCP报文段的长度是4B的整数倍。

### 5.3.2 TCP连接管理

![image-20250701205230527](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250701205230527.png)

---

![image-20250626160202494](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250626160202494.png)

 ![image-20250701174103347](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250701174103347.png)

---

####  建立连接时：

##### SNY，ACK，seq，ack的变化

![image-20250701180103571](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250701180103571.png)

![image-20250701184141470](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250701184141470.png)

 >1. 握手1和握手2的TCP报文没有数据部分，只有首部。但仍然会**消耗一个序号**（TCP协议的特别规定）。 
 >
 >2. 但**握手3可以选择携带数据与否**，携带的情况下会消耗序号，不携带则不消耗。
 >
 >   图中握手1的seq为666，握手2的ack变为了667。
 >
 >3. 在TCP的全过程中，只有**握手1和握手2的SNY=1**。

##### 进程TCP状态是如何变化的（考前看一眼）

![image-20250701180751433](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250701180751433.png)

>   

##### 建立连接，释放连接的最短耗时分析

![image-20250701185142190](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250701185142190.png)

> RTT就是往返时延。

#### 释放连接时：

##### SNY，ACK，seq，ack的变化

![image-20250701200257314](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250701200257314.png)

4次挥手可以分为两次交互，每次交互信息就关闭发送方的单向连接。**挥手2和挥手3为同一方发送**

> 1. TCP的全过程中，只有挥手1，挥手3的FIN=1
> 2. 挥手1、挥手3即使不携带数据，也要消耗一个序号
> 3. 挥手2可以携带数据（双方还没完全断开）
> 4. 挥手4不可以携带数据（双方已经完全断开）

 

##### 进程TCP状态是如何变化的（考前看一眼）

![image-20250701202315308](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250701202315308.png)

> 挥手3后，进入一个2MSL的等待时间
>
> 可以由服务器先开始挥手。

##### 建立连接，释放连接的最短耗时分析

![image-20250701203314934](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250701203314934.png)

> MSL最长报文段寿命一般是800ms
>
> MSS是最大报文段长度 

![image-20250701203706290](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250701203706290.png)

   

### 5.3.3 TCP可靠传输，流量控制

![image-20250702161017425](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250702161017425.png)

---

#### 流量控制机制 

![image-20250705160154037](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250705160154037.png)

> 服务器和客户端都有各自的接收窗口和发送窗口，因为是双向传输，收发双方一直在互换。

---



#### ![image-20250702161452696](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250702161452696.png)

> 握手1和握手2不带数据，但会把序号加1
>
> 握手2和握手3互相通知对方自己的接收窗口大小

![image-20250702164218202](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250702164218202.png)

> TCP协议是双向传输的，所以建立连接的双方都有各自的发送接受缓冲区。
>
> 1. 本机发送缓冲区的大小>=本机发送窗口的大小
> 2. 对方的接受缓冲区大小>=本机发送窗口大小

**流量控制是通过数据的接收方发送自己的接受缓冲区（接受窗口）大小给数据的发送方实现的(数据的发送方以此调节自己的发送窗口大小)**

![image-20250702165054430](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250702165054430.png)

> 一个端口可以建立多个TCP连接
>
> 每个TCP仅支持1对1通信 

#### 累计确认

![image-20250702161435693](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250702161435693.png)

发送缓冲区在接收到ack确认时进行刷新

接受缓冲区在满的时候向应用层交付，然后进行刷新

**接收方在接收到多个连续的报文段后，只返回一个ACK,并且向发送方告知剩余的接受窗口的大小 rwnd **

![image-20250702193009704](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250702193009704.png)

（图中第二个黄色有误，~~虽然缓冲区未满，但只要...应用层~~，应该为缓冲区已满，交付应用层）

> 捎带确认就是双发互发数据的时候，顺便回复对方ACK

**有序交付指的是马上交付的数据和已经交付的数据是连贯的序号**(不能出现跳号，重复的情况)

#### 超时重传机制**

![image-20250705165714776](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250705165714776.png)

---

报文段发出后开始，发送方开始计时，等待接收方的接收报文，时间到没有收到就重发报文。

##### 推迟确认和立即确认

推迟确认：

接收方收到报文后，**等待最多0.5秒后再向发送方进行确认**报文的回复。

优点：可以进行累计确认，一次性确认多个连发的报文。

缺点：

![image-20250705161315748](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250705161315748.png)

如图所示，在连续发送过程中，如果第二个报文出错，将导致发送方无法得知后面的报文被接收（因为接收方需要按序确认）。与此同时，由于发送方在之前已经发送完自己发送窗口内的所有报文（即进行了连续发送），导致它后续收到接收方的 ACK 确认报文时，其发送窗口已为空（数据还在发送缓冲区），没有新的数据可以立即发送。更关键的是，接收方的接收窗口此时正等待着本该由超时重传机制恢复的丢失报文（即后续的报文）。这种状态下，**双方都将陷入只能等待超时重传发生，才能激活并推进传输的停滞局面**。

立即确认（快重传机制）：

![image-20250705163210665](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250705163210665.png)

如图所示，对每个报文都进行ack回复，**623报文出错，就一直发送ack为623的报文**，而**快重传机制在收到1+3（1个正常的ack回复报文，3个冗余ack重复报文）个ack=623的报文后就立即重发**对应的报文。

---

**快重传机制易错点**

第一个ack=623的报文不是冗余ack，因此上图中还需要一次ack=623的报文才会进行快重传。

---

### 5.3.4 拥塞控制

![image-20250705210129439](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250705210129439.png)

发送窗口的值=min[ rwnd , cwnd ]

> 发送窗口的值等于接受方接受窗口和拥塞控制窗口中小的那一个

流量控制是**控制端到端**的数据发生量，是“局部的”

拥塞控制是**控制整个网络**中每台主机的数据发送量，降低路由器负载，是“全局的” 

---



![image-20250705205140059](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250705205140059.png)

---

![image-20250705173506077](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250705173506077.png)

> 收到冗余ACK，意味着发送的数据有丢失

通过让拥塞窗口变小，间接让发送窗口变小，从而降低整个网络的数据发送量，从而达到拥塞控制的目的。



####  慢开始阶段**

![image-20250705205140059](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250705205140059.png)

**慢开始 (Slow Start)**(cwnd < ssthresh)

1. **目的：**

   - 在 **连接刚建立时** 或 **因严重拥塞（超时丢包）而大幅降低发送速率后**，用于**快速探测网络当前的可用带宽**。
   - 它以谨慎的、但**指数级增长**的速度增加发送量，以便尽快找到网络能够承受的传输速度上限。

   > 叫慢开始是因为以非常谨慎（cwnd=1MSS）的方式开始。但他的增长速率是极快（指数级增长）的。

2. **工作原理：**

   - 关键变量：

     - **拥塞窗口 (`cwnd`)**: 发送方根据网络拥塞状况自己维护的一个窗口，表示一次最多可以发送多少字节的数据。**这是发送速率的直接控制者。** 初始值通常很小（如 `1 MSS` - 最大报文段大小）。
     - **慢开始门限 (`ssthresh`)**: 一个预设的阈值（单位通常是字节）。初始值通常较高（如 `64 KB` 或系统默认值）。当拥塞发生时会调整它（通常是减半）。

   - 操作规则：

     - 当 `cwnd < ssthresh` 时，处于慢开始阶段。
     - **增长规则：发送方每收到一个对 新数据 的有效 ACK，就将 `cwnd` 增加 1 个 MSS (`cwnd = cwnd + 1 MSS`)。**

   - 实际效果：

     - 因为在一个往返时间（RTT）内，发送方通常会发送 `cwnd` 大小的数据，并收到约 `cwnd / MSS` 个 ACK。

     - 根据增长规则，这意味着在每个 RTT 结束时，`cwnd` 会翻倍！（`cwnd` 增加的量 ≈ `(cwnd / MSS) * 1 MSS = cwnd`）。

     - **这就是指数增长：1 -> 2 -> 4 -> 8 -> 16 -> ...**

       > **cwnd指数增长最大到ssthresh的值**，即ssthresh=12,cwnd=8，cwnd增大后最大到12，而不是16.

#### 拥塞避免阶段**

![image-20250705205145044](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250705205145044.png)

**拥塞避免 (Congestion Avoidance)**（cwnd > ssthresh）

1. **目的：**

   - 在 **`cwnd` 达到或超过 `ssthresh`** 之后启用。
   - 此时认为发送速率已经接近网络的当前容量上限。继续指数增长风险太大，容易直接导致拥塞。
   - 其目标是在网络边缘**小心翼翼地维护稳定状态**，通过更温和的**线性增长**来继续探测潜在的多余带宽，同时尽量避免触发丢包。

   > 通过主动降低增长速率（指数级->线性增加）来避免进入拥塞

2. **工作原理：**

   - **关键变量：** 同慢开始 (`cwnd`, `ssthresh`)。
   - 操作规则：
     - 当 `cwnd >= ssthresh` 时，处于拥塞避免阶段。
     - **增长规则 (加性增)：对于每一个接收到的 新数据 的 ACK，将 `cwnd` 增加 `1 / cwnd` 个 MSS。** (更直观的理解是：**每个 RTT 只增加 1 个 MSS**)。算法通常这样实现：维护一个增量计数器，每收到一个 ACK 就增加 `1 / cwnd` MSS。当这个计数器累计超过 1 MSS 时，实际将 `cwnd` 增加 1 MSS，并重置计数器。这确保了在一个 RTT 内，无论收到多少个 ACK，`cwnd` 最多只增加约 1 MSS。
     - 例如，`cwnd = 20 MSS`：每收到一个新数据的 ACK，`cwnd` 增加 `1/20 MSS`。收到 20 个 ACK 后，`cwnd` 增加 `(20 * 1/20) = 1 MSS`，变成 21 MSS（刚好一个 RTT 内增加 1 MSS）。
   - **实际效果：** `cwnd` **按线性增长**，非常缓慢地爬升。例如：20 -> 21 -> 22 -> 23 -> ... MSS 每 RTT。

#### 图例理解

![image-20250705214720571](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250705214720571.png)

![image-20250705215135424](D:\文献\笔记\408计算机网络\5.传输层.assets\image-20250705215135424.png)

> 图中发生了严重拥塞，即超时重传

**发送拥塞时**

1. 当收到**1+3个重复的ACK触发快重传**，就是发送了**轻微拥塞**（丢失了个别报文）

将ssthresh设为当前cwnd的一半（ssthresh=cwnd/2，最小为2），并且把新的cwnd设为 ssthresh+3 MSS（一种补充机制）。此时就是进入了**快速恢复阶段**

2. 发生**超时重传**时，就是发送了**严重拥塞**

**此时就把ssthresh的值设为当前cwnd值的一半（最小为2），并且重新从1开始进行慢开始**







#### 快重传机制（冗余ACK）->快回复阶段

 



